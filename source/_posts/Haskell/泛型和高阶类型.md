---
title: 泛型和高阶类型
date: 2024-02-21 21:36:51
tags: [Haskell, Rust, FP, Lean4, HKT, Generics]
---

# 什么是高阶类型
要说明高阶类型，首先要清楚什么是普通类型(proper types)，简单来说是指一切具有值的可实例化的类型，例如Haskell的`Int`、`String`。  
什么不是proper types？比如Haskell的`Maybe`和`IO`不是，因为它需要一个类型参数，不是"完整的类型"。但是`Maybe Int`和`Maybe String`是，因为它们补充了类型参数。

Haskell中proper types叫做`*`，这是一个阶(kind)，阶是对类型的分类。`Int :: *`表示`Int`是一个`*`，当然`String`也是一个`*`。  
而上面提到的`Maybe`的阶不是`*`而是`* -> *`，表示它接受一个`*`并返回一个`*`。~~*准确说法是映射，不是接受和返回*~~。  
像`Maybe`和这样的阶的形式为`P -> Q`的类型叫做**高阶类型**，其中的P和Q都是阶。例如mtl中的`StateT :: * -> (* -> *) -> * -> *`就是一个复杂的高阶类型。

# 高阶类型的作用
假如没有高阶类型的概念，我们就只能考虑`*`这一个阶，因此就无法给`Maybe`这样接受类型参数的符号直接分配一个类型，而是必须这样说：
> 对任意的类型`a`，`Maybe a`也是一个类型。

所以高阶类型最直接的作用就是扩张了类型的范围。

Functor的定义用到了高阶类型：

```Haskell
class Functor (f :: * -> *) where
    fmap :: forall a b. (a -> b) -> f a -> f b
```
其中`f`的阶是`* -> *`，表示有一个类型参数的高阶类型，这样像`Int`、`String`这样的类型就不可能是Functor。

# 高阶类型和泛型的区别
前面说过Haskell的`Maybe`是高阶类型，因为它接受一个类型参数并且返回另一个类型，那么类比到Rust，泛型`Option<T>`是高阶类型吗？答案是否定的，`Option<T>`的含义就是上面提到过的：
> 对任意的类型`T`，`Option<T>`也是一个类型。

单独拿出来`Option`符号是没有类型的。

你可能会说：我假装Option是高阶类型不行吗？有什么是Rust表达不了的吗？  
还真有，例如上面提到过的Haskell的`StateT :: * -> (* -> *) -> * -> *`，可以看作接受三个类型参数的高阶类型，其中第二个类型参数的阶是`* -> *`，因此同样是一个高阶类型。  
类比到Rust中是形如`StateT<S,M,A>`的泛型，但问题是这里的`M`无法被约束为高阶类型`* -> *`，而只能是一个Rust的`*`。同样的，因为缺少高阶类型，Haskell的Functor无法直接被移植到Rust中。

以C#为例，具有泛型的语言总是考虑以下几个概念：
* Unbound Type: 未绑定任何泛型参数的类型，例如`Foo<T,V>`。
* Constructed Type: 至少绑定了一个泛型参数的类型，例如`Foo<T,int>`，这里的`int`也可以换成当前类的泛型参数。
* Open Type: 类型定义的类型形参(parameter)，例如`Foo<T>`的定义内部的`T`。
* * Open Type的数组也是Open Type，例如给定泛型形参`T`，则`T[]`也是Open Type。
* * 有至少一个Open Type作为类型实参(argument)也是Open Type，例如`Task<T>`。
* Closed Type: 非Open Type的所有类型，例如所有非泛型。

可以看出来偏好泛型的语言总是倾向于把`Foo<T,V>`整体当成一个类型，而把其中缺少的类型参数当成需要填充的洞，不会把`Foo`独立出来讨论，也不会有`Foo<T,>`这样"填充了一半"的类型。

*note: 实际上Haskell也有泛型，以上的泛型指的是C#、Rust等类型系统较弱的泛型。*