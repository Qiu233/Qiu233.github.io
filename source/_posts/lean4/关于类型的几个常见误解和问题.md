---
title: 关于类型的几个常见误解和问题
date: 2024-02-23 23:03:27
tags: [Lean4, Type]
---

这篇文章的目的是为刚接触类型论的程序员解答一些可能遇到的误解和问题。会随时间补充。

# term vs value
如果读者写过一些工程语言的代码，那么可能会认为**类型**是对**值**的分类。例如C#中的`int`的值有`-1`、`0`、`100`等等，但表达式`1+1`的类型同样是`int`，你可能会说`1+1`是`2`所以也是`int`，但类型必须从语言内来考虑，而`1+1=2`是元语言的逻辑得到的。

不扯远了，实际上编程语言中的**类型**是对**项**(term)进行的分类，项的定义取决于语言的设计。例如C#和Java等语言中把expression和statement区别开来，但是如果把statement当成类型为`void`的expression，这时expr和stmt就可以统一当成term来看待。在一些类型系统更复杂(比如说支持Dependent Type)的语言中项的定义也会更复杂，例如在Lean4中`1`是类型为`Nat`的项，同时`Nat`又是类型为`Sort 1`的项，`Sort 1`又是类型为`Sort 2`的项，以此类推。

项必须有分配的类型，否则就是无效(invalid)的项，例如Java中`"1" + 2`就是无效的项。规定哪些项是有效的推理规则叫做typing judgement，例如下面这条说明了Java的`int`的加法规则(例1)：

$$\frac{\Gamma \vdash x:\text{int} \quad \Gamma \vdash y:\text{int}}{\Gamma \vdash (x + y) : \text{int}}{\ +_\text{int}}$$

例如Haskell中的`Maybe`类型的阶(kind)是`* -> *`，所以有(例2)：

$$\frac{\Gamma \vdash \tau:\ast}{\Gamma \vdash (\text{Maybe } \tau) : \ast}\ {(\ast \to \ast)}_{\text{Maybe}}$$

例如Lean4中函数类型(例3)：

$$\frac{\Gamma \vdash A:\text{Sort u}\quad\Gamma \vdash B:\text{Sort 0}}{\Gamma \vdash (A\to B):\text{Sort 0}}{\ \to_{v=0}} \qquad \frac{\Gamma \vdash A:\text{Sort u} \quad \Gamma \vdash B:\text{Sort v}}{\Gamma \vdash (A \to B) : \text {Sort (max u v)}}\ \to_{v\ne 0}$$

# constructor
本节的内容对建立universe的直观十分重要，务必仔细理解。

constructor在OOP语言中是一类特殊的函数，接受一些参数然后返回类型的实例(值)。这个理解放到Lean4中会发生什么呢？例如说下面的归纳定义的类型(例4)：
```Haskell
inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat
```
定义了`Nat`类型的两个构造器，`zero : Nat`没有参数，`succ : Nat -> Nat`有一个参数。再例如说structure(例5)：
```Haskell
structure Subtype {α : Sort u} (p : α → Prop) where
  val : α
  property : p val
```
只有一个需要两个参数的构造器。

---

到此为止似乎都没问题。但是请注意：Lean4中**类型也具有类型**，例如上面的`Nat`的类型就是`Sort 1`，所以类比到`zero`是`Nat`的一个构造器，`Nat`是不是`Sort 1`的一个构造器？答案是肯定的。实际上这里`Nat`就是类型`Sort 1`的一个零元(nullary)构造器。而上面的`Subtype`是`Sort (max 1 u)`的一个二元构造器。这里提到的构造器准确来说叫做type constructor，但是它和例4与例5的构造器没有本质区别，考虑下面这个例子(例6)：
```Haskell
structure A (α : Type) where
  val : α
```
其中`A`的类型是`Type -> Type`，也就是`Sort 1 -> Sort 1`。我们已经知道`Sort 1 : Sort 2`，所以在`Sort 2`这个universe内来看`A`就是一个函数。以上讨论可以直接类比到`Sort 1`中，例如`Nat : Sort 1`，此时`A`和`Nat.succ : Nat -> Nat`这样的函数没有本质区别。

---

(例7):
```Haskell
inductive Foo : Type
```
在给定以上定义的情况下有以下三个关系：
$$\begin{aligned}\text{Foo}:&\text{Type}:\text{Sort 2}:\cdots(1)\\
(0+1):\mathbb N:&\text{Type}:\text{Sort 2}:\cdots(2)\\
(\text{by intro h; contradiction}):(0\ne 1):\text{Prop}:&\text{Type}:\text{Sort 2}:\cdots(3)\end{aligned}$$

(0)表示$\text{Foo}$没有任何构造器。(2)不再赘述。  
重点是(3)中$0\ne 1$也是一个类型，它左侧的值正是它作为命题的证明。如果把`Type`作为树的共同父节点，可以发现(3)最左侧的证明比(2)最左侧的`0+1`还要要深一个层次，而(2)比(1)也要深一个层次。实际上我们对$\text{Sort 0}$以上的每个层次都可以用例7的代码定义一个无构造器的类型。


# ∀量词
$\forall$量词在dependent type理论中是$\Pi$ Type，即Lean4中以下两个term是完全等价的：

$$(\forall x:\alpha, \beta) \equiv ((x : \alpha) \to \beta)$$

根据例3可知$((x : \alpha) \to \beta)$的类型与$\alpha$和$\beta$的类型有关，下面分类讨论：

第一种情况，$\beta:\text{Sort 0}$也就是$\beta:\text{Prop}$，那么无论$\alpha$的类型如何，$((x : \alpha) \to \beta)$的类型都是$\text{Prop}$本身。相当于对命题加上一个全称量词∀仍然是一个命题。注意这里$\beta$有可能是依赖于$\alpha$的，例如$((x : \mathbb N) \to x + 1 = \text{Nat.succ }x)$就是一个$\text{Prop}$。

第二种情况，$\beta:\text{Sort v}$且$v\ne 0$，那么$((x : \alpha) \to \beta)$的类型是$\alpha,\beta$的类型中最大的那个。例如$((x : \mathbb N) \to \mathbb N)$的类型是$\text{Sort 1}$；$((x : \text{Type}) \to \mathbb N)$的类型是$\text{Sort 2}$，同理$((x : \mathbb N) \to \text{Type})$的类型也是$\text{Sort 2}$。

*待补充*